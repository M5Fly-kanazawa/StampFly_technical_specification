# PMW3901MB Optical Motion Sensor Implementation Guide

## 1.0 Introduction: PMW3901MB Sensor Overview and Guide Purpose

The PMW3901MB-TXQT is an advanced optical motion tracking chip developed by PixArt Imaging Inc. This sensor employs Far Field Optics Technology and is specifically designed for aerial navigation. It enables high-precision X-Y coordinate positioning and motion detection for flying vehicles such as drones, even in indoor environments or specific outdoor areas where GPS signals are unavailable. Its applications are extensive, playing a central role in various devices requiring autonomous positioning.

This technical document is a practical implementation guide for connecting the PMW3901MB sensor to a microcontroller (MCU) in an embedded system and maximizing its performance. This guide provides detailed step-by-step procedures to accomplish the following three core tasks:

1. **Establishing SPI Interface**: Configuration and operation of the 4-wire SPI protocol that forms the foundation for communication with the sensor.
2. **Executing Proper Initialization Sequence**: A series of essential procedures from power-on to register configuration to ensure stable sensor operation.
3. **Reading Motion Data**: Standard readout procedures for accurately acquiring X-Y displacement data and utilizing the faster burst mode.

The procedures detailed in this guide are key to ensuring stable operation and optimal performance of the sensor. By mastering these fundamentals, you will successfully integrate the sensor into your project.

---

## 2.0 SPI Interface Basics: Establishing Communication

All communication with the PMW3901MB sensor is conducted via 4-wire SPI (Serial Peripheral Interface). Properly understanding and configuring this interface is a prerequisite for all operations, including sensor internal register configuration and motion data readout.

### SPI Signal Pin Roles

The following four main signal pins are used for communication with the sensor:

- **SCLK (Serial data clock)**: Clock signal generated by the master microcontroller. Data transmission and reception are synchronized to this signal.
- **MOSI (Master Out / Slave In)**: Data line for transmitting data from the microcontroller to the sensor. Used when sending register addresses and write data.
- **MISO (Master In / Slave Out)**: Data line for transmitting data from the sensor to the microcontroller. Data read from registers is returned through this line.
- **NCS (Chip select)**: Signal for selecting and enabling the PMW3901MB sensor as the communication target device. When this pin goes Low, the sensor accepts SPI communication (active low).

### SPI Communication Protocol

SPI communication consists of two basic operations: "write operation" and "read operation."

#### Write Operation

Operation for writing data from the microcontroller to a sensor register. The transaction consists of 2 bytes.

1. **Address Byte**: The first byte consists of the target register address (7 bits) and a flag indicating write operation (1 bit). For write operations, the most significant bit (MSB) of the address byte must be set to 1.
2. **Data Byte**: The second byte contains the 8-bit data to be written to the register.

#### Read Operation

Operation for reading data from a sensor register. This operation is also a 2-byte transaction.

1. **Address Byte**: The microcontroller sends an address byte containing the address (7 bits) of the register to be read. For read operations, the MSB of the address byte must be set to 0.
2. **Data Byte**: After the master completes 8 SCLK cycles for sending the address byte, during the next 8 SCLK cycles, the sensor (slave) returns the requested 8 bits of data through the MISO line. The master receives this data.

These basic SPI operations form the foundation for executing register settings at each step in the sensor initialization sequence explained in the next section.

---

## 3.0 Initialization and Configuration Sequence: Sensor Startup Procedure

To maximize the performance of the PMW3901MB sensor and ensure stable operation, it is essential to execute the strict initialization sequence specified in the datasheet. Omitting this procedure or executing it in the wrong order will cause the sensor to not operate as expected and output inaccurate data.

### Power-On Sequence

The initial procedure from power-on until the sensor becomes communication-ready is as follows:

1. **Power-On**: Supply power to VDDIO, then supply power to VDD within 100ms.
2. **Wait Time**: Wait at least 40ms for the power to stabilize.
3. **SPI Port Reset**: Drive the NCS pin High once, then Low to reset the SPI port.
4. **Power-Up Reset**: Write the value 0x5A to the Power_Up_Reset register (address 0x3A) to reset the entire chip.
5. **Wait Time**: Wait at least 1ms for the reset process to complete.
6. **Initial Readout**: Read registers 0x02, 0x03, 0x04, 0x05, 0x06 once each, regardless of the motion pin state.

### Performance Optimization Register Configuration

Following the basic power-up sequence above, the following register configuration sequence must be executed to properly configure the sensor's internal algorithms and achieve optimal performance. These settings are proprietary information from PixArt and consist of logic including direct writes and conditional branches. As these items are essential for stable sensor operation, they must be implemented accurately.

First, write the following initial settings:

```c
// Address, Value
Write 0x7F, 0x00
Write 0x55, 0x01
Write 0x50, 0x07
Write 0x7F, 0x0E
```

Next, execute conditional verification processing.

1. **Verification Sequence**:
   1. Write 0x10 to register 0x43.
   2. Read register 0x47.
   3. Verify that the read value is 0x08. If it does not match, retry this sequence (steps 1 and 2) up to 3 times. If it still fails, stop processing as an error and consider re-powering the sensor.
2. **Conditional Write**:
   1. Read register 0x67.
   2. If bit 7 of the read value is set (is 1), write 0x04 to register 0x48.
   3. If bit 7 is not set (is 0), write 0x02 to register 0x48.

Continue by writing the following settings:

```c
// Address, Value
Write 0x7F, 0x00
Write 0x51, 0x7B
Write 0x50, 0x00
Write 0x55, 0x00
Write 0x7F, 0x0E
```

Next, calculate and apply the sensor calibration values (C1, C2).

1. Read register 0x73. If the read value is not 0x00, skip all the following calculation and write procedures.
2. If the read value is 0x00, execute the following procedures:
   1. Read the current C1 value from register 0x70 and C2 value from register 0x71.
   2. Calculate the new C1 value:
      - `if (C1 <= 28) then new_C1 = C1 + 14`
      - `else new_C1 = C1 + 11`
      - The calculation result is capped at 0x3F.
   3. Calculate the new C2 value: `new_C2 = (C2 * 45) / 100`
   4. Write the calculated new values to the sensor in the following sequence:

```c
// Address, Value
Write 0x7F, 0x00
Write 0x61, 0xAD
Write 0x51, <new_C1>  // New C1 value calculated above
Write 0x7F, 0x0E
Write 0x70, <new_C1>  // New C1 value calculated above
Write 0x71, <new_C2>  // New C2 value calculated above
```

After C1/C2 processing is complete (or skipped), continue with the following sequence:

```c
// Address, Value
Write 0x7F, 0x00
Write 0x61, 0xAD
Write 0x7F, 0x03
Write 0x40, 0x00
Write 0x7F, 0x05
Write 0x41, 0xB3
Write 0x43, 0xF1
Write 0x45, 0x14
Write 0x5B, 0x32
Write 0x5F, 0x34
Write 0x7B, 0x08
Write 0x7F, 0x06
Write 0x44, 0x1B
Write 0x40, 0xBF
Write 0x4E, 0x3F
Write 0x7F, 0x08
Write 0x65, 0x20
Write 0x6A, 0x18
Write 0x7F, 0x09
Write 0x4F, 0xAF
Write 0x5F, 0x40
Write 0x48, 0x80
Write 0x49, 0x80
Write 0x57, 0x77
Write 0x60, 0x78
Write 0x61, 0x78
Write 0x62, 0x08
```

Wait 10ms here.

After waiting, write the remaining register settings:

```c
// Address, Value
Write 0x32, 0x44
Write 0x7F, 0x07
Write 0x63, 0x50
Write 0x7F, 0x0A
Write 0x45, 0x60
Write 0x7F, 0x00
Write 0x4D, 0x11
Write 0x55, 0x80
Write 0x74, 0x1F
Write 0x75, 0x1F
Write 0x4A, 0x78
Write 0x4B, 0x78
Write 0x44, 0x08
Write 0x45, 0x50
Write 0x64, 0xFF
Write 0x65, 0x1F
Write 0x7F, 0x14
Write 0x65, 0x67
Write 0x66, 0x08
Write 0x63, 0x70
Write 0x7F, 0x15
Write 0x48, 0x48
Write 0x7F, 0x07
Write 0x41, 0x0D
Write 0x43, 0x14
Write 0x4B, 0x0E
Write 0x45, 0x0F
Write 0x44, 0x42
Write 0x4C, 0x80
Write 0x7F, 0x10
Write 0x5B, 0x02
Write 0x7F, 0x07
Write 0x40, 0x41
Write 0x70, 0x00
Write 0x40, 0x40
Write 0x7F, 0x06
Write 0x62, 0xF0
Write 0x63, 0x00
Write 0x7F, 0x0D
Write 0x48, 0xC0
Write 0x6F, 0xD5
Write 0x7F, 0x00
Write 0x5B, 0xA0
Write 0x4E, 0xA8
Write 0x5A, 0x50
Write 0x40, 0x80
```

With the completion of this complex initialization sequence, the sensor is ready to accurately generate and report motion data.

---

## 4.0 Reading Motion Data: Acquiring X-Y Displacement

From a sensor with completed initialization and configuration, motion data indicating X-axis and Y-axis movement (displacement) can be acquired. There are two methods for data readout: the basic "standard mode" and "burst mode," which enables faster data transfer.

### Standard Readout Procedure

In the standard procedure, the presence of motion is confirmed before reading each displacement data individually.

1. **Read Motion Register**: First, read the Motion register (address 0x02). This operation freezes (locks) the values of the Delta_X_L/H and Delta_Y_L/H registers, preventing values from updating during readout.
2. **Confirm Motion Occurrence**: Verify that bit 7 of the read Motion register is set (is 1). If this is 1, it indicates some movement has occurred since the last readout.
3. **Acquire Displacement Data**: If bit 7 is set, read the following registers in order:
   - Delta_X_L (address 0x03)
   - Delta_X_H (address 0x04)
   - Delta_Y_L (address 0x05)
   - Delta_Y_H (address 0x06)
4. By combining these L (low byte) and H (high byte), compose the X displacement and Y displacement as 16-bit signed integers respectively.

### High-Speed Burst Mode Readout

Burst mode is an efficient function for continuously reading multiple register data in a single SPI transaction.

- **Advantage**: Since it is not necessary to specify the address of each register individually, SPI communication overhead is significantly reduced. This reduces MCU processing load and enables faster data sampling.
- **Procedure**: By starting a read operation on the Motion_Burst register (address 0x16), burst mode is activated. The sensor continuously returns 12 bytes of data through the MISO line.
- **Important Note**: After receiving 12 bytes of data, the NCS pin must be returned to High once. This terminates burst mode and resets the SPI port. Without this operation, the next SPI communication cannot be performed normally.

### Important: Motion Data Validity Filtering

To improve the reliability of motion data acquired from the PMW3901MB and suppress erroneous motion reports, it is extremely important to apply the following filtering process. This rule is a universal best practice that should be applied to data acquired in both standard mode and burst mode.

- **Filtering Condition**: In the acquired data frame, when the SQUAL register (address 0x07) value is less than 0x19 AND the Shutter_Upper register (address 0x0C) value is 0x1F.
- **Processing**: When the above conditions are met, the Delta_X and Delta_Y values acquired in that frame may have low reliability and are strongly recommended to be discarded.

It is important to appropriately select between standard mode and burst mode according to the application's real-time requirements and MCU processing capability.

---

## 5.0 Conclusion and Best Practices

This guide has explained the core procedures for implementing the PMW3901MB optical motion sensor into an embedded system. The best practices that are key to success are summarized in the following three points:

- **Establishing Accurate SPI Communication**: Strictly adhering to the write (MSB=1) and read (MSB=0) protocols specified in the datasheet is fundamental to all operations.
- **Executing Strict Initialization Sequence**: Reliably executing the series of specified procedures in the correct order, from power-on to performance optimization register configuration, ensures stable sensor operation and performance.
- **Selecting Appropriate Data Readout Method**: Strategically choosing between standard mode for reading individual registers and burst mode for efficient continuous readout is required according to system real-time requirements and processing load constraints.

By utilizing the procedures and information provided in this guide, we are confident that you can successfully integrate the PMW3901MB sensor into your system and build a solid foundation for maximizing its excellent navigation capabilities.
