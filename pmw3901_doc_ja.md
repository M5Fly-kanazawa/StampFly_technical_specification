# PMW3901MB オプティカルモーションセンサー 実装ガイド

## 1.0 はじめに：PMW3901MBセンサーの概要

### 1.1 本ドキュメントの目的

本ガイドは、PixArt社の高性能オプティカルモーションセンサー「PMW3901MB」をシステムに効率的かつ確実に組み込むための、実践的な技術リファレンスです。PMW3901MBは、ドローンやナビゲーションシステムにおいて、特にGPSが利用できない環境下での自己位置推定に不可欠な役割を果たします。このガイドでは、公式データシートに散在する情報の中から、実装に直接必要となる初期化シーケンス、モーションデータの読み出しプロトコル、そして高度なフレームキャプチャ手順を抽出し、エンジニアが直面する課題を解決するための手順ベースの解説を提供します。

### 1.2 PMW3901MBセンサーのコア機能と仕様の評価

PMW3901MBは、PixArt社の遠距離光学（far field optics）技術を基盤とした最新のオプティカルナビゲーションチップです。この技術により、レンズの焦点合わせを必要とせず、空中でのナビゲーションを可能にします。センサーは、連続的に画像要素（ピクセル）を取得し、その変化を数学的に解析することで、移動の方向と大きさを算出します。このコア機能は、内蔵された画像取得システム（PEAS）とデジタル信号処理システム（DSPS）によって実現されています。

本センサーの主要な特徴と仕様は、ドローンなどの移動体への応用において以下の戦略的利点をもたらします。

- **広範な動作範囲 (80 mmから無限遠)**: 地面からの距離が変動するドローンや移動ロボットでも、安定したモーション検知を可能にします。
- **シンプルなインターフェース (4線式SPI @ 2 MHz)**: 多くのマイクロコントローラ（MCU）で標準的にサポートされており、システムへの統合が容易です。
- **柔軟な供給電圧 (VDD: 1.8–2.1V, VDDIO: 1.8–3.6V)**: 低電圧システムにも対応可能で、様々な電源設計に柔軟に適合します。
- **高精度なモーションデータ (16ビット)**: X-Y方向の移動量を高分解能で取得でき、精密な位置制御に貢献します。
- **低消費電力 (ランモード時 9mA未満)**: バッテリー駆動のアプリケーションにおいて、長時間の運用を実現するための重要な要素です。

これらの機能を最大限に活用するためには、センサーとの正確な通信が不可欠です。次章では、その基盤となるSPIインターフェースの仕様と設定について詳しく解説します。

---

## 2.0 SPIインターフェースの仕様と設定

### 2.1 SPI通信の基礎

PMW3901MBとの全ての制御コマンドの送信とデータ受信は、4線式SPI（Serial Peripheral Interface）を介して行われます。この通信プロトコルを正確に理解し、正しく実装することは、センサーの性能を最大限に引き出すための第一歩です。特に、チップセレクト（NCS）の操作は、トランザクションの区切りを定義し、通信の信頼性を確保する上で極めて重要です。

以下に、SPI通信に使用される主要なピンの役割を示します。

| ピン名 | タイプ | 説明 |
|--------|--------|------|
| SCLK | Input | マスター（MCU）から供給されるシリアルクロック信号です。 |
| MOSI | Input | マスターからスレーブ（センサー）へのデータ入力ラインです（Master Out / Slave In）。 |
| MISO | Output | スレーブ（センサー）からマスターへのデータ出力ラインです（Master In / Slave Out）。NCSがHighの時はハイインピーダンス（Hi-Z）状態になります。 |
| NCS | Input | チップセレクト信号（アクティブロー）。このピンをLowにすることで、センサーとのSPI通信が有効になります。 |

#### チップセレクト（NCS）の操作に関する注意点

NCSは単に通信の開始を告げるだけでなく、トランザクションの完全性を保証する役割も担います。通信の途中でNCSがHighになると、そのトランザクションは即座に中断され、シリアルポートはリセットされます。通信エラーが発生した場合も、NCSを一度HighにしてからLowに戻すことで、ポートをリセットし、安定した状態に復帰させることができます。

### 2.2 書き込み（Write）および読み込み（Read）操作のシーケンス分析

#### 書き込み（Write）操作

センサーのレジスタに設定値を書き込む操作は、2バイト（16ビット）のトランザクションで構成されます。

1. MCUはNCSをLowにし、通信を開始します。
2. アドレスバイトを送信します。このバイトの最上位ビット（MSB）は1に設定し、書き込み操作であることを示します。残りの7ビットでターゲットとなるレジスタのアドレスを指定します。
3. データバイトを送信します。この8ビットが、指定したレジスタに書き込まれる値です。
4. データ転送完了後、MCUはNCSをHighに戻し、トランザクションを終了します。

*[図: 書き込み操作シーケンス (データシート Figure 9 参照)]*

#### 読み込み（Read）操作

センサーのレジスタから値を読み出す操作も、同様に2バイトのトランザクションで構成されますが、データの方向が異なります。

1. MCUはNCSをLowにし、通信を開始します。
2. アドレスバイトを送信します。このバイトのMSBは0に設定し、読み込み操作であることを示します。残りの7ビットで読み出したいレジスタのアドレスを指定します。
3. アドレス送信後、センサーは次の8クロックサイクルでMISOラインを通じてデータバイトを返します。MCUはこのデータを受信します。
4. データ受信後、MCUはNCSをHighに戻し、トランザクションを終了します。

*[図: 読み込み操作シーケンス (データシート Figure 11 参照)]*

#### コマンド間のタイミング規定

安定した通信を維持するため、データシートではコマンド間の最小待機時間が規定されています。これらの遅延は、センサーの内部プロセッサが書き込みやデータ準備といった操作を完了し、次のコマンドを受け付ける準備を整えるために不可欠です。

- **t_SWW (45 µs)**: 書き込みから次の書き込みまでの最小時間
- **t_SWR (45 µs)**: 書き込みから次の読み込みまでの最小時間
- **t_SRR/t_SRW (20 µs)**: 読み込みから次のコマンド（読み込み/書き込み）までの最小時間
- **t_SRAD (35 µs)**: 読み込みコマンドでアドレスを送信してから、データが準備されるまでの最小待機時間

これらのタイミング規定を遵守しない場合、コマンドが正しく実行されない可能性があるため、ファームウェア設計時に十分な遅延を挿入することが推奨されます。

これらの基本的なSPI操作を理解した上で、次の章ではセンサーを正常に起動させるための具体的な初期化手順について解説します。

---

## 3.0 センサーの初期化手順

### 3.1 電源投入シーケンスとリセット

センサーが正確なモーションデータを生成するためには、電源投入後に厳密な初期化シーケンスを実行することが不可欠です。この手順を正しく行うことで、センサー内部のレジスタが適切な状態に設定され、安定した動作の基盤が確立されます。

推奨される電源投入シーケンスは以下の通りです。

1. **電源供給**: VDDIO（I/O電圧）に電源を供給し、その後100msを超えない遅延でVDD（コア電圧）に電源を供給します。両方の電源が安定するのを待ちます。
2. **待機**: 電源安定後、最低でも40ms待機します。
3. **SPIポートのリセット**: NCSピンを一度HighにしてからLowにドライブし、SPIポートをリセットします。
4. **パワーアップリセット**: Power_Up_Resetレジスタ（アドレス 0x3A）に0x5Aを書き込みます。これにより、チップ全体がリセットされます。
5. **待機**: リセットコマンド書き込み後、最低でも1ms待機します。
6. **初期読み出し**: モーションピンの状態に関わらず、レジスタ0x02から0x06（モーション関連レジスタ）を一度読み出します。

#### 補足：ハードウェアリセット

NRESETピン（アクティブロー）を使用することで、ソフトウェアリセット（Power_Up_Resetレジスタへの書き込み）と同様のフルチップリセットを実行することも可能です。NRESETピンを100ns以上Lowに保持することでリセットがかかります。このピンはフローティング（未接続）状態にすることはできません。

### 3.2 パフォーマンス最適化レジスタの設定

電源投入シーケンスの完了後、センサーの性能を最適化するために、一連の特定レジスタに規定値を書き込む必要があります。この設定は、PixArt社独自の調整項目であり、データシートでは各レジスタの詳細な機能は公開されていませんが、最適なパフォーマンスを得るためには必須の手順です。

以下に、書き込むべきレジスタのシーケンスを示します。条件分岐を含むため、コメントを参考に正確に実装してください。

```c
// Address, Value
{0x7F, 0x00},
{0x55, 0x01},
{0x50, 0x07},
{0x7F, 0x0E},

// --- 条件付き書き込みシーケンス開始 ---
// 備考: 0x47から0x08が読み出せない場合、0x43に0x10を書き込み、再度0x47を読む。
// これを最大3回試行する。成功しない場合は、センサーの電源を再投入してやり直す。
{0x43, 0x10}, // 必要に応じて書き込む
// Read(0x47) が 0x08 になることを確認

// 0x67のBit7を読み出し、その値に応じて0x48に書き込む値を決定
// value = Read(0x67)
// if (value & 0x80) { Write(0x48, 0x04) } else { Write(0x48, 0x02) }
// --- 条件付き書き込みシーケンス終了 ---

{0x7F, 0x00},
{0x51, 0x7B},
{0x50, 0x00},
{0x55, 0x00},
{0x7F, 0x0E},

// --- 条件付き設定ブロック ---
// value = Read(0x73)
// if (value != 0x00) {
//   // Read(0x73)が0x00でない場合、以下の計算と書き込みを実行
//   C1 = Read(0x70);
//   if (C1 <= 0x1C) { C1 += 0x0E; } else { C1 += 0x0B; }
//   if (C1 > 0x3F) { C1 = 0x3F; }
//   C2 = Read(0x71);
//   C2 = (C2 * 45) / 100;
//
//   {0x7F, 0x00},
//   {0x61, 0xAD},
//   {0x51, 0x70},
//   {0x7F, 0x0E},
//   {0x70, C1},
//   {0x71, C2},
// }
// --- 条件付き設定ブロック終了 ---

{0x7F, 0x00},
{0x61, 0xAD},
{0x7F, 0x03},
{0x40, 0x00},
{0x7F, 0x05},
{0x41, 0xB3},
{0x43, 0xF1},
{0x45, 0x14},
{0x5B, 0x32},
{0x5F, 0x34},
{0x7B, 0x08},
{0x7F, 0x06},
{0x44, 0x1B},
{0x40, 0xBF},
{0x4E, 0x3F},
{0x7F, 0x08},
{0x65, 0x20},
{0x6A, 0x18},
{0x7F, 0x09},
{0x4F, 0xAF},
{0x5F, 0x40},
{0x48, 0x80},
{0x49, 0x80},
{0x57, 0x77},
{0x60, 0x78},
{0x61, 0x78},
{0x62, 0x08},

// --- 10msの遅延を挿入 ---
delay(10);

{0x32, 0x44},
{0x7F, 0x07},
{0x40, 0x41},
{0x63, 0x50},
{0x7F, 0x0A},
{0x45, 0x60},
{0x7F, 0x00},
{0x4D, 0x11},
{0x55, 0x80},
{0x74, 0x1F},
{0x75, 0x1F},
{0x4A, 0x78},
{0x4B, 0x78},
{0x44, 0x08},
{0x45, 0x50},
{0x64, 0xFF},
{0x65, 0x1F},
{0x7F, 0x14},
{0x65, 0x67},
{0x66, 0x08},
{0x63, 0x70},
{0x7F, 0x15},
{0x48, 0x48},
{0x7F, 0x07},
{0x41, 0x0D},
{0x43, 0x14},
{0x4B, 0x0E},
{0x45, 0x0F},
{0x44, 0x42},
{0x4C, 0x80},
{0x7F, 0x10},
{0x5B, 0x02},
{0x7F, 0x07},
{0x70, 0x00},

// 10msの遅延は不要 (データシートTable 10のDelayは1回のみ)
// Wait 15ms after the write to 0x70, then read register 0x15.
// The read back value should be 0xBF. This is part of observation check.
// The sequence continues here.
{0x40, 0x40},
{0x7F, 0x06},
{0x62, 0xF0},
{0x63, 0x00},
{0x7F, 0x0D},
{0x48, 0xC0},
{0x6F, 0xD5},
{0x7F, 0x00},
{0x5B, 0xA0},
{0x4E, 0xA8},
{0x5A, 0x50},
{0x40, 0x80}
```

この初期化と最適化が完了すると、センサーはモーションデータを生成する準備が整います。次のセクションでは、このデータ（X-Y移動量）を実際に読み出すための手順を解説します。

---

## 4.0 モーションデータ（移動量）の読み出し手順

### 4.1 標準的なモーションデータの読み出し

センサーの主要な目的は、X-Y平面上の移動量を検出することです。初期化が完了した後、このモーションデータを周期的に読み出すことで、デバイスの位置や動きを追跡します。データの信頼性を確保するため、読み出し手順と合わせて品質チェックを行うことが重要です。

標準的なモーションデータの読み出し手順は以下の通りです。

1. **モーション発生の確認**: Motionレジスタ（アドレス 0x02）を読み出します。この読み出し操作により、移動量データレジスタ（Delta_X_L/H, Delta_Y_L/H）の値がフリーズ（固定）されます。
2. **データ有無の判定**: Motionレジスタのビット7（MOT7）が1であるかを確認します。1の場合、前回の読み出し以降に新たなモーションが検出されたことを意味します。
3. **移動量データの取得**: MOT7が1の場合、以下のレジスタを順に読み出します。
   - Delta_X_L (アドレス 0x03)
   - Delta_X_H (アドレス 0x04)
   - Delta_Y_L (アドレス 0x05)
   - Delta_Y_H (アドレス 0x06)
4. _L（下位バイト）と_H（上位バイト）を結合して、それぞれ16ビットの符号付き整数（2の補数表現）としてX方向とY方向の移動量データを合成します。
5. **データ品質の検証**: 取得したデータの信頼性を評価するため、SQUALレジスタ（アドレス 0x07）とShutter_Upperレジスタ（アドレス 0x0C）の値を読み出します。データシートでは、SQUALの値が0x19未満 かつ Shutter_Upperの値が0x1F の場合、そのデータは信頼性が低い可能性があるため、破棄することが推奨されています。この状態は、特徴のない表面や不十分な照明など、センサーが動きを確実に追跡できない劣悪な視認性を示唆します。

この手順を繰り返すことで、連続的なモーションデータを取得できます。

### 4.2 高速なデータ読み出し：バーストモードの活用

より高速かつ効率的にモーション関連データを一括で取得したい場合、バーストモードが有効です。バーストモードを使用すると、一度のアドレス指定で最大12バイトのデータを連続して読み出すことができ、SPIトランザクションのオーバーヘッドを削減できます。

バーストモードの利用手順は以下の通りです。

1. NCSをLowにして通信を開始します。
2. Motion_Burstレジスタのアドレス（0x16）を送信します。
3. t_SRAD（35µs）の時間、待機します。
4. SCLKを連続して駆動し、最大12バイトのデータをMISOから読み出します。
5. 読み出し完了後、NCSをHighに戻してバーストモードを終了します。

バーストモードで読み出される12バイトのデータの内訳は以下の通りです。

- BYTE[00]: Motion
- BYTE[01]: Observation
- BYTE[02]: Delta_X_L
- BYTE[03]: Delta_X_H
- BYTE[04]: Delta_Y_L
- BYTE[05]: Delta_Y_H
- BYTE[06]: SQUAL
- BYTE[07]: RawData_Sum
- BYTE[08]: Maximum_RawData
- BYTE[09]: Minimum_RawData
- BYTE[10]: Shutter_Upper
- BYTE[11]: Shutter_Lower

このモードは、移動量だけでなく、表面品質（SQUAL）やシャッター値など、センサーの状態を総合的に監視する際に特に便利です。

モーションデータの取得はセンサーの基本的な機能ですが、デバッグや特殊な画像解析のためには、センサーが捉えている生の画像データそのものが必要になる場合があります。次の章では、そのためのフレームキャプチャ手順について解説します。

---

## 5.0 フレームキャプチャ手順

### 5.1 フレームキャプチャモードへの移行とデータ取得

フレームキャプチャは、センサーの撮像素子が捉えている35x35ピクセル（合計1225ピクセル）の生の画像データを直接ダウンロードするための特殊な機能です。この機能は、主にデバッグ、表面のテクスチャ分析、または高度な画像処理アルゴリズムの開発に使用されます。

**重要**: フレームキャプチャモード中は、通常のナビゲーション（モーション検知）機能は無効化されます。また、モードの移行とデータ取得には厳密な手順が要求されます。

フレームキャプチャの実行プロセスは、大きく3つのステップに分かれます。

#### 1. フレームキャプチャモードへの移行

以下のレジスタ書き込みシーケンスを順に実行し、センサーをフレームキャプチャモードに設定します。

#### 2. データ取得準備と実行

- **a. 初期化**: レジスタ 0x70 に 0x00 を書き込み、次に RawData_Grab レジスタ（アドレス 0x58）に 0xFF を書き込み、データ取得プロセスを開始します。
- **b. 準備完了のポーリング**: RawData_Grab_Status レジスタ（アドレス 0x59）を繰り返し読み出し、ビット6（データが位置0,0から開始）とビット7（データ取得が有効）の両方が1になるまで待機します。
- **c. データ読み出しと再構成**: RawData_Grab レジスタ（0x58）を繰り返し読み出します。各ピクセルのデータ（8ビット）は、2回の読み出しに分割されて返されます。
  - **1回目の読み出し**: RDG[7:6]が01となり、RDG[5:0]にピクセルデータの上位6ビットが格納されています。
  - **2回目の読み出し**: RDG[7:6]が10となり、RDG[3:2]にピクセルデータの下位2ビットが格納されています。

  これらを結合して、1ピクセル分の8ビットデータを復元します。このプロセスを1225ピクセル分繰り返します。

#### 3. フレームキャプチャモードからの離脱

以下のレジスタ書き込みシーケンスを実行し、センサーを通常モードに戻す準備をします。

**注意**: このシーケンス実行後、ナビゲーション機能を復元するためには、手動でのリセットが必須です。Power_Up_Resetレジスタ（0x3A）に0x5Aを書き込むか、NRESETピンをトグルしてください。

この高度な機能に続き、最後に、バッテリー駆動デバイスで特に重要となるセンサーの省電力管理、すなわちパワーダウン手順について解説します。

---

## 6.0 パワーダウン（シャットダウン）手順

### 6.1 シャットダウンモードへの移行と復帰

特にバッテリーで駆動されるアプリケーションにおいて、システムの消費電力を最小限に抑えることは極めて重要です。PMW3901MBは、非アクティブ時に消費電流を約12µAまで削減するシャットダウンモードを備えています。このモードを適切に活用することで、デバイスの動作時間を大幅に延長できます。

#### シャットダウンモードへの移行

センサーをシャットダウンモードに移行させる手順は非常にシンプルです。

- Shutdown レジスタ（アドレス 0x3B）に 0xB6 を書き込みます。

このコマンドを実行すると、センサーは低消費電力状態に入ります。シャットダウン中は、SPIポートへのアクセスは（復帰コマンドを除き）行わないでください。

#### シャットダウンモードからの復帰

シャットダウンモードから通常のランモードに復帰する手順は、電源投入時のシーケンスとほぼ同じです。これは、シャットダウンによって内部状態がリセットされるため、再度の初期化が必要となるからです。

1. **SPIポートのリセット**: NCSピンを一度HighにしてからLowにドライブします。
2. **パワーアップリセット**: Power_Up_Reset レジスタ（アドレス 0x3A）に 0x5A を書き込みます。
3. **待機と初期読み出し**: 1ms以上待機した後、レジスタ0x02から0x06を一度読み出します。
4. **再初期化**: 「3.2 パフォーマンス最適化レジスタの設定」で解説した一連のレジスタ設定を再度実行します。

#### シャットダウン中のピン状態に関する注意点

シャットダウンモード中のシステム設計においては、各ピンの状態を考慮する必要があります。

| ピン名 | シャットダウン中の状態 | 注意事項 |
|--------|----------------------|----------|
| NRESET | High | Highレベルに保持する必要があります。 |
| NCS | High | SPIバスを他のデバイスと共有している場合は、必ずHighに保持してください。 |
| MISO | Hi-Z | 不定状態を避けるため、外部でプルアップまたはプルダウンすることが推奨されます。 |
| SCLK | Ignore (if NCS=High) | NCSがHighであれば、SCLK信号は無視されます。 |
| MOSI | Ignore (if NCS=High) | NCSがHighであれば、MOSI信号は無視されます。 |
| MOTION | Output High | モーション割り込みピンはHighレベルで出力されます。 |

---

## まとめ

本ガイドでは、PMW3901MBオプティカルモーションセンサーの実装に必要な全ての基本的な手順を解説しました。適切な初期化、正確なSPI通信、そして目的に応じたデータ読み出し方法を理解することで、このセンサーをドローンやナビゲーションシステムに効果的に統合できます。
